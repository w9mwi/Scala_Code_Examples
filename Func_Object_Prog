This sample program demonstrates FUNCTIONAL OBJECT PROGRAMMING.
Functional Object Programming is what's used by the Scala API,
where all code in the Scala API classes and objects DON'T have
a mutable state--none of the methods mutate the internal state
of the class/object.  Like a Scala List class, for example.

See the corresponding Modular_Func_Prog file to see how this
program is written using MODULAR FUNCTIONAL PROGRAMMING.

object Demo
{
  type Money = BigDecimal
  object Price
  {
    val zeroDollars:Money      = BigDecimal(0.00D).setScale(2)
    val pizzaBasePrice:Money   = BigDecimal(10.00D).setScale(2)
    val pizzaTopping:Money     = BigDecimal(1.00D).setScale(2)
    val crustTypeRegular:Money = zeroDollars
    val crustTypeThin:Money    = BigDecimal(1.00D).setScale(2)
    val crustTypeThick:Money   = BigDecimal(2.00D).setScale(2)
    val pizzaSizeSmall:Money   = zeroDollars
    val pizzaSizeMedium:Money  = BigDecimal(1.00D).setScale(2)
    val pizzaSizeLarge:Money   = BigDecimal(2.00D).setScale(2)
  }

  sealed trait Topping
  case object Cheese    extends Topping
  case object Mushrooms extends Topping
  case object Onions    extends Topping
  case object Olives    extends Topping
  case object Pepperoni extends Topping
  case object Sausage   extends Topping

  sealed trait PizzaSize
  case object PizzaSizeSmall  extends PizzaSize
  case object PizzaSizeMedium extends PizzaSize
  case object PizzaSizeLarge  extends PizzaSize

  sealed trait CrustType
  case object CrustTypeRegular extends CrustType
  case object CrustTypeThin    extends CrustType
  case object CrustTypeThick   extends CrustType

  case class Address (street1: String,
                      street2: Option[String],
                      city: String,
                      state: String,
                      zipCode: String)
  {
    override def toString = s"Address($street1, $street2, $city, $state, $zipCode)"
  }

  case class Pizza(pizzaSize: PizzaSize,
                   crustType: CrustType,
                   toppings:  Seq[Topping])
  {
    override def toString = s"Pizza($pizzaSize, $crustType, $toppings)"
    def addTopping(t:Topping):Pizza         = { copy(toppings = toppings :+ t) }
    def removeTopping(t:Topping):Pizza      = { copy(toppings = dropFirstMatch(toppings, t)) }
    def removeAllToppings():Pizza           = { copy(toppings = Seq[Topping]()) } // NOTE: Seq[Topping]() = Nil
    def updatePizzaSize(ps:PizzaSize):Pizza = { copy(pizzaSize = ps) }
    def updateCrustType(ct:CrustType):Pizza = { copy(crustType = ct) }
    //def getPrice(crustSize:PizzaSize, crustType:CrustType, toppings:Seq[Topping]):Money =
    def getPrice():Money =
    {
      val pizzaSizePrice:Money = MockPizzaDao.getCrustSizePrices().getOrElse(pizzaSize, Price.zeroDollars)
      val crustTypePrice:Money = MockPizzaDao.getCrustTypePrices().getOrElse(crustType, Price.zeroDollars)

      // Assign moneySeq the price of each topping on the pizza.
      val moneySeq:Seq[Money] = for { top <- toppings } yield MockPizzaDao.getToppingPrices.getOrElse(top, Price.zeroDollars)
      val toppingsPrice:Money = moneySeq.sum // Obtain the total price of all toppings on the pizza.

      // Return the total price of the pizza.
      Price.pizzaBasePrice + crustTypePrice + pizzaSizePrice + toppingsPrice
    }
  }

  case class Customer(name:String, phone:String, address:Address)
  {
    override def toString = s"Customer($name, $phone, $address)"
  }

  case class Order(pizzas:Seq[Pizza], customer:Customer)
  {
    override def toString = s"Order($customer, $pizzas)"
  }

  trait PizzaDaoInterface // NOTE: Dao = Data Access Object
  {
    def getToppingPrices():Map[Topping, Money]
    def getCrustSizePrices():Map[PizzaSize, Money]
    def getCrustTypePrices():Map[CrustType, Money]
  }

  object MockPizzaDao extends PizzaDaoInterface // NOTE: Dao = Data Access Object
  {
    def getToppingPrices(): Map[Topping, Money] =
    {
      Map(Cheese    -> Price.pizzaTopping,
          Pepperoni -> Price.pizzaTopping,
          Onions    -> Price.pizzaTopping,
          Olives    -> Price.pizzaTopping,
          Mushrooms -> Price.pizzaTopping,
          Sausage   -> Price.pizzaTopping)
    }

    def getCrustSizePrices(): Map[PizzaSize, Money] =
    {
      Map(PizzaSizeSmall -> Price.pizzaSizeSmall,
          PizzaSizeMedium-> Price.pizzaSizeMedium,
          PizzaSizeLarge -> Price.pizzaSizeLarge)
    }

    def getCrustTypePrices(): Map[CrustType, Money] =
    {
      Map(CrustTypeRegular -> Price.crustTypeRegular,
          CrustTypeThick   -> Price.crustTypeThick,
          CrustTypeThin    -> Price.crustTypeThin)
    }
  }

  /************************************************************************
   * main() function
   *
   * This function creates a single pizza order for a customer.
   * This order contains two pizzas.
   ************************************************************************/
  def main(args: Array[String])
  {
    val address:Address = Address("1717 Philippen St.", None, "Manitowoc", "Wisconsin", "54220")
    val customer:Customer = Customer("Joe Blow", "920-682-1882", address)

    // Create the first pizza (named pizza_1) and print its contents.
    val pizza_1:Pizza = Pizza(PizzaSizeSmall, CrustTypeRegular, Seq(Pepperoni))
    println(s"pizza_1 = $pizza_1")
    var pizzaPrice = pizza_1.getPrice()
    println("pizza_1 Price = $" + pizzaPrice + "\n")

    // Create the second pizza (named pizza_2).
    val pizza_2:Pizza = Pizza(PizzaSizeMedium, CrustTypeThin, Seq(Onions, Olives, Pepperoni))
    println(s"pizza_2 = $pizza_2")

    // Here we decide to change the pizzaSize, crustType, and toppings
    // of pizza_2.  But pizza_2 is a val so it can't be changed.  So
    // "var pizzaUpdated" is declared to accommodate changes made to a pizza.
    var pizzaUpdated = pizza_2.removeAllToppings()
    pizzaUpdated = pizzaUpdated.addTopping(Sausage)
    pizzaUpdated = pizzaUpdated.addTopping(Olives)
    pizzaUpdated = pizzaUpdated.removeTopping(Olives) // Remove the Olives topping just added above.
    pizzaUpdated = pizzaUpdated.addTopping(Mushrooms)
    pizzaUpdated = pizzaUpdated.addTopping(Cheese)
    pizzaUpdated = pizzaUpdated.addTopping(Pepperoni)
    pizzaUpdated = pizzaUpdated.addTopping(Onions)
    pizzaUpdated = pizzaUpdated.updatePizzaSize(PizzaSizeLarge)
    pizzaUpdated = pizzaUpdated.updateCrustType(CrustTypeThick)
    println(s"pizzaUpdated = $pizzaUpdated")
    pizzaPrice = pizzaUpdated.getPrice()
    println("pizzaUpdated Price = $" + pizzaPrice + "\n")

    val order = Order(Seq(pizza_1, pizzaUpdated), customer)
    println(s"order = $order\n")
  }

  /**
   * This function gets passed a Seq containing values, and a single value.
   * The first occurrence of the value passed to this function is removed
   * from that Seq, and then the Seq is returned.
   */
  def dropFirstMatch[A](seq:Seq[A], value:A): Seq[A] =
  {
    val index:Int = seq.indexOf(value)
    if (index < 0) { seq }  // index = -1 if there is no match.
    else if (index == 0) { seq.tail }
    else
    {
      // splitAt() splits a Seq into a prefix and suffix.
      // The prefix contains Seq elements 0 through index.
      // The suffix contains the remaining Seq, beginning
      // with element index+1, which is the matching element.
      val (a:Seq[A], b:Seq[A]) = seq.splitAt(index)
      a ++ b.tail // The returned Seq drops the head of Seq b.
    }
  }
}
